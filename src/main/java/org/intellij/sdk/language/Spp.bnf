{
    parserClass = "org.intellij.sdk.language.parser.SppParser"
    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Spp"
    psiImplClassSuffix = "Impl"
    psiPackage="org.intellij.sdk.language.psi"
    psiImplPackage="org.intellij.sdk.language.psi.impl"

    elementTypeHolderClass = "org.intellij.sdk.language.psi.SppTypes"
    elementTypeClass = "org.intellij.sdk.language.psi.SppElementType"
    tokenTypeClass = "org.intellij.sdk.language.psi.SppTokenType"

    tokens = [
        TK_DBL_AMPERSAND = "&&"
        TK_DBL_AMPERSAND_EQUALS = "&&="
        TK_DBL_PIPE = "||"
        TK_DBL_PIPE_EQUALS = "||="
        TK_EXCLAMATION = "!"

        TK_AMPERSAND = "&"
        TK_AMPERSAND_EQUALS = "&="
        TK_PIPE = "|"
        TK_PIPE_EQUALS = "|="
        TK_CARET = "^"
        TK_CARET_EQUALS = "^="

        TK_DBL_EQUALS = "=="
        TK_EXCLAMATION_EQUALS = "!="
        TK_ANGLE_L = "<"
        TK_ANGLE_L_EQUALS = "<="
        TK_ANGLE_R = ">"
        TK_ANGLE_R_EQUALS = ">="
        TK_ARROW_FAT_DBL = "<=>"

        TK_PLUS = "+"
        TK_PLUS_EQUALS = "+="
        TK_HYPHEN = "-"
        TK_HYPHEN_EQUALS = "-="
        TK_ASTERISK = "*"
        TK_ASTERISK_EQUALS = "*="
        TK_FORWARD_SLASH = "/"
        TK_FORWARD_SLASH_EQUALS = "/="
        TK_PERCENT = "%"
        TK_PERCENT_EQUALS = "%="

        TK_PAREN_L = "("
        TK_PAREN_R = ")"
        TK_BRACKET_L = "["
        TK_BRACKET_R = "]"
        TK_BRACE_L = "{"
        TK_BRACE_R = "}"

        TK_QUESTION = "?"

        TK_PIPE_ARROW_L = "<|"
        TK_PIPE_ARROW_R = "|>"
        TK_DBL_DOT = ".."
        TK_TRIP_DOT = "..."
        TK_COLON = ":"

        TK_DOT = "."
        TK_DBL_COLON = "::"
        TK_COMMA = ","
        TK_EQUALS = "="
        TK_ARROW_R = "->"
        TK_ARROW_FAT_R = "=>"
        TK_AT = "@"
        TK_UNDERSCORE = "_"
        TK_SEMICOLON = ";"

        KW_MOD = "mod"
        KW_USE = "use"
        KW_ENUM = "enum"
        KW_IN = "in"
        KW_FN = "fn"
        KW_GN = "gn"
        KW_MUT = "mut"
        KW_LET = "let"
        KW_IF = "if"
        KW_ELIF = "elif"
        KW_ELSE = "else"
        KW_WHILE = "while"
        KW_FOR = "for"
        KW_DO = "do"
        KW_MATCH = "match"
        KW_RET = "ret"
        KW_YIELD = "yield"
        KW_CLS = "cls"
        KW_WHERE = "where"
        KW_TRUE = "true"
        KW_FALSE = "false"
        KW_AS = "as"
        KW_SUP = "sup"
        KW_WITH = "with"
        KW_BREAK = "break"
        KW_CONT = "cont"
        KW_SELF = "Self"

        line_comment="regexp:(#.*)"
        block_comment="regexp:(\"\"\"[^\"]*\"\"\")"

        LX_IDENTIFIER = "regexp:([_a-zA-Z][_a-zA-Z0-9]*)"
        LX_BIN_DIGITS = "regexp:(0b[01]+)"
        LX_HEX_DIGITS = "regexp:(0x[0-9a-fA-F]+)"
        LX_DEC_DIGITS = "regexp:([0-9]+)"
        LX_DBL_QUOTE_STR = "regexp:(\".*\")"
        LX_SNG_QUOTE_CHR = "regexp:('.?')"
        LX_REGEX = "regexp:(r\".*\")"
        LX_TAG = "regexp:('[a-zA-Z0-9_]+)"
    ]
}


Program ::= ModulePrototype <<eof>>

ModulePrototype ::= Decorators? KW_MOD ModuleIdentifier TK_SEMICOLON ModuleImplementation
ModuleImplementation ::= ImportBlock? ModuleMember*
ModuleIdentifier ::= Identifier (TK_DBL_COLON Identifier)*
ModuleMember ::= FunctionPrototype | EnumPrototype | ClassPrototype | SupPrototype

ImportBlock ::= ImportStatement+
ImportStatement ::= KW_USE ImportIdentifier ImportWhat TK_SEMICOLON
ImportIdentifier ::= (Identifier TK_DBL_COLON)+
ImportWhat ::= ImportAll | ImportSome | ImportOne
ImportAll ::= TK_ASTERISK
ImportSome ::= TK_BRACE_L ImportType (TK_COMMA ImportType)+ TK_BRACE_R
ImportOne ::= ImportType
ImportType ::= Identifier ImportAlias?
ImportAlias ::= TK_AS Identifier

ClassPrototype ::= Decorators? KW_CLS ClassIdentifier TypeGenericParameters? ClassMetaclass? WhereBlock? TK_BRACE_L ClassImplementation TK_BRACE_R
ClassMetaclass ::= KW_WITH TypeIdentifier
ClassImplementation ::= ClassMember*
ClassMember ::= ClassAttribute
ClassAttribute ::= Decorators? KW_MUT? ClassAttributeIdentifier TK_COLON TypeIdentifier TK_SEMICOLON
ClassIdentifier ::= Identifier
ClassAttributeIdentifier ::= Identifier

SupPrototype ::= KW_SUP (SupPrototypeWithInherit | SupPrototypeNormal)
SupPrototypeNormal ::= TypeGenericParameters? SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupPrototypeWithInherit ::= TypeGenericParameters? SupIdentifier KW_FOR SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupImplementation ::= SupMember*
SupMember ::= SupMethodPrototype | SupTypedef
SupIdentifier ::= TypeIdentifier
SupTypedef ::= Decorators? StatementTypedef
SupMethodPrototype ::= FunctionPrototype

EnumPrototype ::= Decorators? KW_ENUM EnumIdentifier TypeGenericParameters? WhereBlock? TK_BRACE_L EnumImplementation TK_BRACE_R
EnumImplementation ::= (EnumMember (TK_COMMA EnumMember)*)? TK_SEMICOLON
EnumMember ::= EnumMemberIdentifier (TK_EQUALS NonAssignmentExpression)?
EnumMemberIdentifier ::= Identifier
EnumIdentifier ::= Identifier

FunctionPrototype ::= Decorators? (KW_FN | KW_GN) FunctionIdentifier TypeGenericParameters? FunctionParameters TK_ARROW_R TypeIdentifiers WhereBlock? ValueGuard? TK_BRACE_L FunctionImplementation TK_BRACE_R
FunctionImplementation ::= Statement*
FunctionIdentifier ::= Identifier

FunctionCallArguments ::= TK_PAREN_L FunctionCallArgumentsNormalThenNamed? TK_PAREN_R
FunctionCallArgumentsNormalThenNamed ::= FunctionCallNamedArguments | FunctionCallNormalArguments
FunctionCallNormalArguments ::= FunctionCallNormalArgument (TK_COMMA FunctionCallArgumentsNormalThenNamed)?
FunctionCallNamedArguments ::= FunctionCallNamedArgument (TK_COMMA FunctionCallNamedArgument)*
FunctionCallNormalArgument ::= ParameterPassingConvention? OperatorIdentifierVariadic? NonAssignmentExpression
FunctionCallNamedArgument ::= FunctionCallNamedArgumentIdentifier TK_EQUALS ParameterPassingConvention? NonAssignmentExpression
FunctionCallNamedArgumentIdentifier ::= Identifier

FunctionParameters ::= TK_PAREN_L FunctionParametersRequiredThenOptional? TK_PAREN_R
FunctionParametersRequiredThenOptional ::= FunctionParameterVariadic | FunctionParametersOptional | FunctionParametersRequired
FunctionParametersOptionalThenVariadic ::= FunctionParameterVariadic | FunctionParametersOptional
FunctionParametersRequired ::= FunctionParameterRequired (TK_COMMA FunctionParametersRequiredThenOptional)?
FunctionParametersOptional ::= FunctionParameterOptional (TK_COMMA FunctionParametersOptionalThenVariadic)?
FunctionParameterRequired ::= KW_MUT? FunctionParameterIdentifier TK_COLON ParameterPassingConvention? TypeIdentifier
FunctionParameterOptional ::= FunctionParameterRequired TK_EQUALS NonAssignmentExpression
FunctionParameterVariadic ::= OperatorIdentifierVariadic FunctionParameterRequired
FunctionParameterIdentifier ::= Identifier

WhereBlock ::= KW_WHERE TK_BRACKET_L WhereConstraintChain TK_BRACKET_R
WhereConstraintChain ::= WhereConstraint (TK_COMMA WhereConstraintChain)*
WhereConstraint ::= TypeIdentifiers TK_COLON WhereConstraintConstraints
WhereConstraintConstraints ::= TypeIdentifier (TK_AMPERSAND TypeIdentifier)*
ValueGuard ::= KW_IF NonAssignmentExpression

Decorator ::= TK_AT DecoratorIdentifier TypeGenericArguments? FunctionCallArguments?
Decorators ::= Decorator+
DecoratorIdentifier ::= TypeIdentifier  //?

Expressions ::= Expression (TK_COMMA Expression)*
Expression ::= ExpressionAssignment
NonAssignmentExpression ::= ExpressionLogicalOr
ExpressionAssignment ::= ExpressionAssignmentMultiple | ExpressionAssignmentSingle
ExpressionAssignmentSingle ::= NonAssignmentExpression (OperatorIdentifierAssignment NonAssignmentExpression)?
ExpressionAssignmentMultiple ::= NonAssignmentExpression (TK_COMMA NonAssignmentExpression)* TK_EQUALS NonAssignmentExpression
ExpressionLogicalOr ::= ExpressionLogicalAnd (TK_DBL_PIPE ExpressionLogicalOr)?
ExpressionLogicalAnd ::= ExpressionBitwiseOr (TK_DBL_AMPERSAND ExpressionLogicalAnd)?
ExpressionBitwiseOr ::= ExpressionBitwiseXor (TK_PIPE ExpressionBitwiseOr)?
ExpressionBitwiseXor ::= ExpressionBitwiseAnd (TK_CARET ExpressionBitwiseXor)?
ExpressionBitwiseAnd ::= ExpressionEquality (TK_AMPERSAND ExpressionBitwiseAnd)?
ExpressionEquality ::= ExpressionRelational (OperatorIdentifierEquality ExpressionEquality)?
ExpressionRelational ::= ExpressionAdditive (OperatorIdentifierRelational ExpressionRelational)?
ExpressionAdditive ::= ExpressionMultiplicative (OperatorIdentifierAdditive ExpressionAdditive)?
ExpressionMultiplicative ::= ExpressionPipe (OperatorIdentifierMultiplicative ExpressionMultiplicative)?
ExpressionPipe ::= ExpressionPostfix (OperatorIdentifierPipe ExpressionPipe)?
ExpressionPostfix ::= ExpressionPrimary OperatorIdentifierPostfix*
ExpressionPrimary ::= Literal | Lambda | TypeIdentifierSingle | Identifier | ExpressionPlaceholder | StatementIf | StatementMatch | StatementWhile | StatementFor | StatementDo | StatementNewScope | OperatorIdentifierVariadic
ExpressionPlaceholder ::= TK_UNDERSCORE

Lambda ::= LambdaCaptureList? LambdaParameters TK_ARROW_FAT_R LambdaImplementation
LambdaCaptureList ::= TK_BRACKET_L LambdaCaptureItem (TK_COMMA LambdaCaptureItem)* TK_BRACKET_R
LambdaCaptureItem ::= (Identifier TK_EQUALS)? ParameterPassingConvention? Identifier
LambdaParameters ::= TK_PAREN_L LambdaParametersRequired? TK_PAREN_R
LambdaParametersRequired ::= LambdaParameterRequired (TK_COMMA LambdaParametersRequired)*
LambdaParameterRequired ::= KW_MUT? FunctionParameterIdentifier
LambdaImplementation ::= NonAssignmentExpression

TypeIdentifier ::= TypeIdentifierSingle | TypeIdentifierTuple
TypeIdentifierSingle ::= ((KW_SELF TK_DBL_COLON)? GenericIdentifier (TK_DBL_COLON (GenericIdentifier | Number))*) | KW_SELF
TypeIdentifierTuple ::= TK_PAREN_L TypeIdentifiers? TK_PAREN_R
TypeIdentifiers ::= TypeIdentifier (TK_COMMA TypeIdentifier)*

TypeGenericArguments ::= TK_BRACKET_L TypeGenericArgumentsNormalThenNamed? TK_BRACKET_R
TypeGenericArgumentsNormalThenNamed ::= TypeGenericArgumentsNamed | TypeGenericArgumentsNormal
TypeGenericArgumentsNormal ::= TypeGenericArgumentNormal (TK_COMMA TypeGenericArgumentsNormalThenNamed)?
TypeGenericArgumentsNamed ::= TypeGenericArgumentNamed (TK_COMMA TypeGenericArgumentNamed)*
TypeGenericArgumentNormal ::= TypeIdentifier
TypeGenericArgumentNamed ::= Identifier TK_EQUALS TypeIdentifier

TypeGenericParameters ::= TK_BRACKET_L TypeGenericParametersRequiredThenOptional? TK_BRACKET_R
TypeGenericParametersRequiredThenOptional ::= TypeGenericParametersVariadic | TypeGenericParametersOptional | TypeGenericParametersRequired
TypeGenericParametersOptionalThenVariadic ::= TypeGenericParametersVariadic | TypeGenericParametersOptional
TypeGenericParametersRequired ::= TypeGenericParameterRequired (TK_COMMA TypeGenericParametersRequiredThenOptional)?
TypeGenericParametersOptional ::= TypeGenericParameterOptional (TK_COMMA TypeGenericParametersOptionalThenVariadic)?
TypeGenericParametersVariadic ::= TypeGenericParameterVariadic (TK_COMMA TypeGenericParameterVariadic)*
TypeGenericParameterRequired ::= TypeGenericParameterIdentifier TypeGenericParameterInlineConstraint?
TypeGenericParameterOptional ::= TypeGenericParameterRequired TK_EQUALS TypeIdentifier
TypeGenericParameterVariadic ::= OperatorIdentifierVariadic TypeGenericParameterRequired
TypeGenericParameterInlineConstraint ::= TK_COLON WhereConstraintConstraints?
TypeGenericParameterIdentifier ::= Identifier

StatementInlineDefinition ::= KW_LET LocalVariableIdentifier TK_EQUALS NonAssignmentExpression TK_COMMA
StatementIf ::= StatementIfBranch StatementElifBranch* StatementElseBranch?
StatementIfBranch ::= KW_IF StatementInlineDefinition* Expression StatementBlock
StatementElifBranch ::= KW_ELIF StatementInlineDefinition* Expression StatementBlock
StatementElseBranch ::= KW_ELSE StatementBlock
StatementWhile ::= KW_WHILE Expression StatementLoopTag? StatementBlock
StatementFor ::= KW_FOR LocalVariableIdentifiers KW_IN Expression StatementLoopTag? StatementBlock
StatementDo ::= KW_DO StatementLoopTag? StatementBlock KW_WHILE Expression
StatementMatch ::= KW_MATCH Expression StatementCases
StatementCaseExpression ::= Expression
StatementCaseExpressions ::= StatementCaseExpression (TK_COMMA StatementCaseExpression)*
StatementCase ::= StatementCaseExpressions ValueGuard TK_ARROW_FAT_R StatementBlock
StatementWith ::= KW_WITH Expression (KW_AS LocalVariableIdentifier)? StatementBlock
StatementReturn ::= KW_RET Expression? TK_SEMICOLON
StatementYield ::= KW_YIELD Expression? TK_SEMICOLON
StatementTypedef ::= KW_USE GenericIdentifier KW_AS TypeIdentifier TK_SEMICOLON
StatementBreak ::= KW_BREAK StatementTagIdentifier? Expression? TK_SEMICOLON
StatementContinue ::= KW_CONTINUE StatementTagIdentifier? TK_SEMICOLON
StatementLoopTag ::= KW_AS StatementTagIdentifier
StatementTagIdentifier ::= LX_TAG
StatementBlock ::= TK_BRACE_L Statement* TK_BRACE_R
StatementCases ::= TK_BRACE_L StatementCase* TK_BRACE_R
StatementLet ::= KW_LET LocalVariableIdentifiers ((TK_COLON TypeIdentifier) | (TK_EQUALS NonAssignmentExpression)) TK_SEMICOLON
StatementExpression ::= Expression TK_SEMICOLON
StatementNewScope ::= TK_BRACE_L Statement* TK_BRACE_R
Statement ::= StatementIf | StatementWhile | StatementFor | StatementDo | StatementMatch | StatementWith | StatementReturn | StatementYield | StatementTypedef | StatementBreak | StatementContinue | StatementLet | StatementExpression | StatementNewScope | FunctionPrototype

LocalVariableIdentifier ::= KW_MUT? Identifier
LocalVariableIdentifiers ::= LocalVariableIdentifier (TK_COMMA LocalVariableIdentifier)*

Identifier ::= LX_IDENTIFIER
GenericIdentifier ::= LX_IDENTIFIER TypeGenericArguments?

PostfixOperatorFunctionCall ::= FunctionCallArguments
PostfixOperatorMemberAccess ::= OperatorIdentifierMemberAccess (GenericIdentifier | Number)
PostfixOperatorStructInitializer ::= TK_BRACE_L PostfixOperatorStructInitializerFields? TK_BRACE_R
PostfixOperatorStructInitializerFields ::= PostfixOperatorStructInitializerField (TK_COMMA PostfixOperatorStructInitializerField)*
PostfixOperatorStructInitializerField ::= PostfixOperatorStructInitializerFieldName (TK_COLON NonAssignmentExpression)?
PostfixOperatorStructInitializerFieldName ::= KW_SUP | KW_ELSE | Identifier

OperatorIdentifierAssignment ::= TK_DBL_PIPE_EQUALS | TK_DBL_AMPERSAND_EQUALS | TK_PIPE_EQUALS | TK_AMPERSAND_EQUALS | TK_CARET_EQUALS | TK_DBL_ANGLE_L_EQUALS | TK_DBL_ANGLE_R_EQUALS | TK_TRIP_ANGLE_L_EQUALS | TK_TRIP_ANGLE_R_EQUALS | TK_PLUS_EQUALS | TK_HYPEHN_EQUALS | TK_ASTERISK_EQUALS | TK_FORWARD_SLASH_EQUALS | TK_DBL_FORWARD_SLASH_EQUALS | TK_PERCENT_EQUALS | TK_DBL_ASTERISK_EQUALS | TK_DBL_QUESTION_MARK_EQUALS
OperatorIdentifierEquality ::= TK_DBL_EQUALS | TK_EXCLAMATION_EQUALS
OperatorIdentifierRelational ::= TK_ANGLE_L | TK_ANGLE_R | TK_ANGLE_L_EQUALS | TK_ANGLE_R_EQUALS | TK_ARROW_FAT_DBL
OperatorIdentifierAdditive ::= TK_PLUS | TK_HYPHEN
OperatorIdentifierMultiplicative ::= TK_ASTERISK | TK_FORWARD_SLASH | TK_DBL_FORWARD_SLASH | TK_PERCENT
OperatorIdentifierPipe ::= TK_PIPE_ARROW_L | TK_PIPE_ARROW_R
OperatorIdentifierVariadic ::= TK_TRIP_DOT
OperatorIdentifierMemberAccess ::= TK_DOT
OperatorIdentifierPostfix ::= PostfixOperatorFunctionCall | PostfixOperatorMemberAccess | PostfixOperatorStructInitializer | TK_QUESTION
ParameterPassingConvention ::= TK_AMPERSAND KW_MUT?

Literal ::= LiteralNumber | LiteralString | LiteralChar | LiteralBool | LiteralTuple | LiteralRegex // | LiteralRange
LiteralNumber ::= LiteralNumberBase02 | LiteralNumberBase10 | LiteralNumberBase16
LiteralString ::= LX_DBL_QUOTE_STR
LiteralChar ::= LX_SNG_QUOTE_CHR
LiteralBool ::= KW_TRUE | KW_FALSE
LiteralTuple ::= TK_PAREN_L Expressions? TK_PAREN_R
LiteralRegex ::= LX_REGEX
// LiteralRange ::= Expression TK_TRIPLE_DOT Expression

LiteralNumberBase02 ::= LX_BIN_DIGITS
LiteralNumberBase10 ::= Number
LiteralNumberBase16 ::= LX_HEX_DIGITS

Number ::= NumericInteger NumericDecimal? NumericComplex? NumericExponent?
NumericInteger ::= LX_DEC_DIGITS
NumericDecimal ::= TK_DOT LX_DEC_DIGITS
NumericComplex ::= "i"
NumericExponent ::= "e" OperatorIdentifierAdditive? NumericInteger
