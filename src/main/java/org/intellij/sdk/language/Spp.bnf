{
    parserClass = "org.intellij.sdk.language.parser.SppParser"
    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Spp"
    psiImplClassSuffix = "Impl"
    psiPackage="org.intellij.sdk.language.psi"
    psiImplPackage="org.intellij.sdk.language.psi.impl"

    elementTypeHolderClass = "org.intellij.sdk.language.psi.SppTypes"
    elementTypeClass = "org.intellij.sdk.language.psi.SppElementType"
    tokenTypeClass = "org.intellij.sdk.language.psi.SppTokenType"

    tokens = [
        TK_DOUBLE_AMPERSAND = "&&"
        TK_DOUBLE_AMPERSAND_EQUALS = "&&="
        TK_DOUBLE_PIPE = "||"
        TK_DOUBLE_PIPE_EQUALS = "||="

        TK_AMPERSAND = "&"
        TK_AMPERSAND_EQUALS = "&="
        TK_PIPE = "|"
        TK_PIPE_EQUALS = "|="
        TK_CARET = "^"
        TK_CARET_EQUALS = "^="

        TK_EQ = "=="
        TK_NE = "!="
        TK_LT = "<"
        TK_LE = "<="
        TK_GT = ">"
        TK_GE = ">="
        TK_SS = "<=>"

        TK_ADD = "+"
        TK_ADD_EQ = "+="
        TK_SUB = "-"
        TK_SUB_EQ = "-="
        TK_MUL = "*"
        TK_MUL_EQ = "*="
        TK_DIV = "/"
        TK_DIV_EQ = "/="
        TK_REM = "%"
        TK_REM_EQ = "%="

        TK_PAREN_L = "("
        TK_PAREN_R = ")"
        TK_BRACK_L = "["
        TK_BRACK_R = "]"
        TK_BRACE_L = "{"
        TK_BRACE_R = "}"

        TK_QST = "?"

        TK_PIPE_ARROW_R = "|>"
        TK_PIPE_ARROW_L = "<|"
        TK_DOUBLE_DOT = ".."
        TK_TRIPLE_DOT = "..."
        TK_COLON = ":"

        TK_DYNA_RES = "."
        TK_STAT_RES = "::"
        TK_COMMA = ","
        TK_EQUAL = "="
        TK_ARROW_RETURN = "->"
        TK_ARROW_R_FAT = "=>"
        TK_AT = "@"
        TK_UNDERSCORE = "_"

        TK_SEMICOLON = ";"

        KW_MOD = "mod"
        KW_USE = "use"
        KW_ENUM = "enum"
        KW_IN = "in"
        KW_FN = "fn"
        KW_GN = "gn"
        KW_MUT = "mut"
        KW_LET = "let"
        KW_IF = "if"
        KW_ELSE = "else"
        KW_WHILE = "while"
        KW_FOR = "for"
        KW_DO = "do"
        KW_RET = "ret"
        KW_YIELD = "yield"
        KW_CLS = "cls"
        KW_WHERE = "where"
        KW_TRUE = "true"
        KW_FALSE = "false"
        KW_AS = "as"
        KW_SUP = "sup"
        KW_WITH = "with"
        KW_BREAK = "break"
        KW_CONT = "cont"
        KW_SELF = "Self"

        line_comment="regexp:(#.*)"
        block_comment="regexp:(\"\"\"[^\"]*\"\"\")"

        LX_IDENTIFIER = "regexp:([_a-zA-Z][_a-zA-Z0-9]*)"
        LX_BIN_DIGITS = "regexp:(0b[01]+)"
        LX_HEX_DIGITS = "regexp:(0x[0-9a-fA-F]+)"
        LX_DEC_DIGITS = "regexp:([0-9]+)"
        LX_DOUBLE_QUOTE_STR = "regexp:(\".*\")"
        LX_SNG_QUOTE_CHR = "regexp:('.?')"
        LX_REGEX = "regexp:(r\".*\")"
        LX_TAG = "regexp:('[a-zA-Z0-9_]+)"
    ]
}


Program ::= ModulePrototype <<eof>>
ModulePrototype ::= Decorators? KW_MOD ModuleIdentifier TK_SEMICOLON ModuleImplementation
ModuleImplementation ::= ImportBlock? ModuleMember*
ModuleIdentifier ::= Identifier ModuleIdentifierNextPart*
ModuleIdentifierNextPart ::= TK_STAT_RES Identifier
ModuleMember ::= (FunctionPrototype | EnumPrototype | ClassPrototype | SupPrototype)

ImportBlock ::= ImportStatement+
ImportStatement ::= KW_USE ImportIdentifier ImportWhat TK_SEMICOLON
ImportIdentifier ::= ImportIdentifierPart+
ImportIdentifierPart ::= Identifier TK_STAT_RES
ImportWhat ::= (ImportAll | ImportSingle | ImportMultiple)
ImportAll ::= TK_MUL
ImportSingle ::= ImportType
ImportMultiple ::= TK_BRACE_L ImportTypes TK_BRACE_R
ImportTypes ::= ImportType ImportTypesNext*
ImportTypesNext ::= TK_COMMA ImportType
ImportType ::= Identifier ImportTypeAlias?
ImportTypeAlias ::= KW_AS Identifier

ClassPrototype ::= Decorators? KW_CLS ClassIdentifier TypeGenericParameters? WhereBlock? TK_BRACE_L ClassImplementation TK_BRACE_R
ClassImplementation ::= ClassMember*
ClassMember ::= ClassAttribute
ClassAttribute ::= Decorators? KW_MUT? ClassAttributeIdentifier TK_COLON TypeIdentifier TK_SEMICOLON
ClassAttributeIdentifier ::= Identifier
ClassIdentifier ::= Identifier

SupPrototype ::= KW_SUP (SupPrototypeWithInherit | SupPrototypeNormal)
SupPrototypeNormal ::= TypeGenericParameters? SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupPrototypeWithInherit ::= TypeGenericParameters? SupIdentifier KW_FOR SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupImplementation ::= SupMember*
SupMember ::= (SupMethodPrototype | SupTypedef)
SupIdentifier ::= SingleTypeIdentifierNoSelf
SupTypedef ::= Decorators? StatementTypedef
SupMethodPrototype ::= FunctionPrototype

EnumPrototype ::= Decorators? KW_ENUM EnumIdentifier TypeGenericParameters? WhereBlock? TK_BRACE_L EnumImplementation TK_BRACE_R
EnumImplementation ::= EnumMember EnumMemberNext* TK_SEMICOLON
EnumMemberNext ::= TK_COMMA EnumMember
EnumMember ::= EnumMemberIdentifier EnumMemberValueWrapper?
EnumMemberValueWrapper ::= TK_EQUAL NonAssignmentExpression
EnumMemberIdentifier ::= Identifier
EnumIdentifier ::= Identifier

FunctionStructureType ::= (KW_FN | KW_GN)
FunctionPrototype ::= Decorators? FunctionStructureType FunctionIdentifier TypeGenericParameters? FunctionParameters TK_ARROW_RETURN TypeIdentifier WhereBlock? ValueGuard? TK_BRACE_L FunctionImplementation TK_BRACE_R
FunctionImplementation ::= Statement*
FunctionIdentifier ::= Identifier

FunctionCallArguments ::= TK_PAREN_L FunctionCallArgumentsNormalThenNamed? TK_PAREN_R
FunctionCallArgumentsNormalThenNamed ::= (FunctionCallNamedArguments | FunctionCallNormalArguments)
FunctionCallNormalArguments ::= FunctionCallNormalArgument FunctionCallRestOfNormalArguments?
FunctionCallRestOfNormalArguments ::= TK_COMMA FunctionCallArgumentsNormalThenNamed
FunctionCallNamedArguments ::= FunctionCallNamedArgument FunctionCallNextNamedArgument*
FunctionCallNextNamedArgument ::= TK_COMMA FunctionCallNamedArgument
FunctionCallNormalArgument ::= ParameterPassingConvention? OperatorIdentifierVariadic? NonAssignmentExpression
FunctionCallNamedArgument ::= FunctionCallNamedArgumentIdentifier TK_EQUAL ParameterPassingConvention? NonAssignmentExpression
FunctionCallNamedArgumentIdentifier ::= Identifier

FunctionParameters ::= TK_PAREN_L FunctionParametersRequiredThenOptional? TK_PAREN_R
FunctionParametersRequiredThenOptional ::= (FunctionVariadicParameters | FunctionOptionalParameters | FunctionRequiredParameters)
FunctionParametersOptionalThenVariadic ::= (FunctionVariadicParameters | FunctionOptionalParameters)
FunctionRequiredParameters ::= FunctionRequiredParameter FunctionRestOfRequiredParameters?
FunctionRestOfRequiredParameters ::= TK_COMMA FunctionParametersRequiredThenOptional
FunctionOptionalParameters ::= FunctionOptionalParameter FunctionRestOfOptionalParameters?
FunctionRestOfOptionalParameters ::= TK_COMMA FunctionParametersOptionalThenVariadic
FunctionVariadicParameters ::= FunctionVariadicParameter
FunctionRequiredParameter ::= KW_MUT? FunctionParameterIdentifier TK_COLON ParameterPassingConvention? TypeIdentifier
FunctionOptionalParameter ::= FunctionRequiredParameter TK_EQUAL NonAssignmentExpression
FunctionVariadicParameter ::= OperatorIdentifierVariadic FunctionRequiredParameter
FunctionParameterIdentifier ::= Identifier

WhereBlock ::= KW_WHERE TK_BRACK_L WhereConstraints TK_BRACK_R
WhereConstraints ::= WhereConstraint WhereConstraintNext*
WhereConstraintNext ::= TK_COMMA WhereConstraint
WhereConstraint ::= TypeIdentifiers TK_COLON WhereConstraintChain
WhereConstraintChain ::= WhereConstraintChainElement WhereConstraintChainElementNext*
WhereConstraintChainElementNext ::= TK_AMPERSAND WhereConstraintChainElement
WhereConstraintChainElement ::= SingleTypeIdentifier
ValueGuard ::= KW_IF NonAssignmentExpression

Decorator ::= TK_AT DecoratorIdentifier TypeGenericArguments? FunctionCallArguments?
Decorators ::= Decorator*
DecoratorIdentifier ::= ModuleIdentifier

Expressions ::= Expression ExpressionNext*
ExpressionNext ::= TK_COMMA Expression
Expression ::= AssignmentExpression

NonAssignmentExpression ::= LogicalOrExpression
AssignmentExpression ::= (AssignmentExpressionMultiple | AssignmentExpressionSingle)
AssignmentExpressionSingle ::= NonAssignmentExpression (OperatorIdentifierAssignment NonAssignmentExpression)?
AssignmentExpressionMultiple ::= NonAssignmentExpression AssignmentMultipleLhs* TK_EQUAL NonAssignmentExpression
AssignmentMultipleLhs ::= TK_COMMA NonAssignmentExpression
LogicalOrExpression ::= LogicalAndExpression (TK_DOUBLE_PIPE LogicalOrExpression)?
LogicalAndExpression ::= BitwiseOrExpression (TK_DOUBLE_AMPERSAND LogicalAndExpression)?
BitwiseOrExpression ::= BitwiseXorExpression (TK_PIPE BitwiseOrExpression)?
BitwiseXorExpression ::= BitwiseAndExpression (TK_CARET BitwiseXorExpression)?
BitwiseAndExpression ::= EqualityExpression (TK_AMPERSAND BitwiseAndExpression)?
EqualityExpression ::= RelationalExpression (OperatorIdentifierEquality RelationalExpression)?
RelationalExpression ::= AdditiveExpression (OperatorIdentifierRelation RelationalExpression)?
AdditiveExpression ::= MultiplicativeExpression (OperatorIdentifierAdditive AdditiveExpression)?
MultiplicativeExpression ::= PipeExpression (OperatorIdentifierMultiplicative MultiplicativeExpression)?
PipeExpression ::= PostfixExpression (OperatorIdentifierPipe PipeExpression)?
PostfixExpression ::= PrimaryExpression OperatorIdentifierPostfix*

PrimaryExpression ::= (StatementIf | StatementWhile | StatementFor | StatementDo | StatementNewScope | StatementYield | StatementWith | PrimaryTypeIdentifier | Lambda | Identifier | Literal | OperatorIdentifierVariadic | ExpressionPlaceholder)
PrimaryTypeIdentifier ::= SingleTypeIdentifier PostfixOperatorStructInitializer
ExpressionPlaceholder ::= TK_UNDERSCORE

Lambda ::= LambdaCaptureList? LambdaParameters TK_ARROW_R_FAT LambdaImplementation
LambdaCaptureList ::= TK_BRACK_L LambdaCaptureItem LambdaCaptureItemNext* TK_BRACK_R
LambdaCaptureItemNext ::= TK_COMMA LambdaCaptureItem
LambdaCaptureItem ::= LambdaCaptureItemAlias? ParameterPassingConvention? Identifier
LambdaCaptureItemAlias ::= Identifier TK_EQUAL
LambdaParameters ::= TK_PAREN_L LambdaParametersRequired? TK_PAREN_R
LambdaParametersRequired ::= LambdaParameterRequired LambdaParameterRequiredNext*
LambdaParameterRequiredNext ::= TK_COMMA LambdaParameterRequired
LambdaParameterRequired ::= KW_MUT? FunctionParameterIdentifier
LambdaImplementation ::= NonAssignmentExpression

SingleTypeIdentifierWithSelf ::= KW_SELF TypeRawIdentifierNext*
SingleTypeIdentifierNoSelf ::= GenericIdentifier TypeRawIdentifierNext*
TypeRawIdentifierNext ::= TK_STAT_RES TypeRawIdentifier
TypeRawIdentifier ::= (GenericIdentifier | TypeIntegerIdentifier)
TypeIntegerIdentifier ::= NumericInteger
TypeIdentifier ::= SingleTypeIdentifier | TupleTypeIdentifiers
SingleTypeIdentifier ::= SingleTypeIdentifierWithSelf | SingleTypeIdentifierNoSelf
TupleTypeIdentifiers ::= TK_PAREN_L TypeIdentifiers? TK_PAREN_R
TypeIdentifiers ::= TypeIdentifier TypeIdentifierNext*
TypeIdentifierNext ::= TK_COMMA TypeIdentifier

TypeGenericArguments ::= TK_BRACK_L TypeGenericArgumentsNormalThenNamed? TK_BRACK_R
TypeGenericArgumentsNormalThenNamed ::= (TypeGenericNamedArguments | TypeGenericNormalArguments)
TypeGenericNormalArguments ::= TypeGenericNormalArgument TypeGenericRestOfNormalArguments?
TypeGenericRestOfNormalArguments ::= TK_COMMA TypeGenericArgumentsNormalThenNamed
TypeGenericNamedArguments ::= TypeGenericNamedArgument TypeGenericNextNamedArgument*
TypeGenericNextNamedArgument ::= TK_COMMA TypeGenericNamedArgument
TypeGenericNormalArgument ::= TypeIdentifier
TypeGenericNamedArgument ::= Identifier TK_EQUAL TypeIdentifier

TypeGenericParameters ::= TK_BRACK_L TypeGenericParametersRequiredThenOptional? TK_BRACK_R
TypeGenericParametersRequiredThenOptional ::= (TypeGenericVariadicParameters | TypeGenericOptionalParameters | TypeGenericRequiredParameters)
TypeGenericParametersOptionalThenVariadic ::= (TypeGenericVariadicParameters | TypeGenericOptionalParameters)
TypeGenericRequiredParameters ::= TypeGenericRequiredParameter TypeGenericRestOfRequiredParameters?
TypeGenericRestOfRequiredParameters ::= TK_COMMA TypeGenericParametersRequiredThenOptional
TypeGenericOptionalParameters ::= TypeGenericOptionalParameter TypeGenericRestOfOptionalParameters?
TypeGenericRestOfOptionalParameters ::= TK_COMMA TypeGenericParametersOptionalThenVariadic
TypeGenericRequiredParameter ::= TypeGenericParameterIdentifier TypeGenericParameterInlineConstraint?
TypeGenericOptionalParameter ::= TypeGenericRequiredParameter TK_EQUAL TypeIdentifier
TypeGenericVariadicParameters ::= TypeGenericVariadicParameter TypeGenericRestOfVariadicParameters?
TypeGenericVariadicParameter ::= TK_TRIPLE_DOT TypeGenericRequiredParameter
TypeGenericRestOfVariadicParameters ::= TK_COMMA TypeGenericVariadicParameter
TypeGenericParameterIdentifier ::= Identifier
TypeGenericParameterInlineConstraint ::= TK_COLON WhereConstraintChain

StatementIf ::= KW_IF NonAssignmentExpression PatternOp? TK_BRACE_L StatementPattern* StatementPatternDefault? TK_BRACE_R
StatementPattern ::= PatternOp? PatternComposite PatternGuard? TK_ARROW_R_FAT Statement
StatementPatternDefault ::= KW_ELSE TK_ARROW_R_FAT Statement
PatternOp ::= (OperatorIdentifierRelation | OperatorIdentifierEquality)
PatternGuard ::= TK_DOUBLE_AMPERSAND NonAssignmentExpression
PatternComposite ::= PatternVal PatternValNext*
PatternVal ::= PostfixExpression
PatternValNext ::= TK_PIPE PatternVal
StatementWhile ::= KW_WHILE Expression StatementLoopTag? StatementNewScope StatementsResidualAction?
StatementFor ::= KW_FOR LocalVariableIdentifiers KW_IN Expression StatementLoopTag? StatementNewScope StatementsResidualAction?
StatementDo ::= KW_DO KW_WHILE Expression StatementLoopTag? StatementNewScope StatementsResidualAction?
StatementWith ::= KW_WITH Expression StatementAliasForWithExpression? StatementNewScope
StatementAliasForWithExpression ::= KW_AS LocalVariableIdentifier
StatementReturn ::= KW_RET Expression? TK_SEMICOLON
StatementYield ::= KW_YIELD Expression?
StatementTypedef ::= KW_USE GenericIdentifier KW_AS TypeIdentifier TK_SEMICOLON
StatementBreak ::= KW_BREAK StatementTagIdentifier? Expression? TK_SEMICOLON
StatementContinue ::= KW_CONTINUE StatementTagIdentifier? TK_SEMICOLON
StatementLoopTag ::= KW_AS StatementTagIdentifier
StatementTagIdentifier ::= LX_TAG
StatementLet ::= (StatementLetWithValue | StatementLetWithType)  TK_SEMICOLON
StatementLetWithValue ::= KW_LET LocalVariableIdentifiers TK_EQUAL NonAssignmentExpression StatementsResidualAction?
StatementsResidualAction ::= KW_ELSE NonAssignmentExpression
StatementLetWithType ::= KW_LET LocalVariableIdentifiers TK_COLON TypeIdentifier
LocalVariableIdentifier ::= KW_MUT? Identifier
LocalVariableIdentifiers ::= LocalVariableIdentifier LocalVariableIdentifierNext*
LocalVariableIdentifierNext ::= TK_COMMA LocalVariableIdentifier
StatementExpression ::= Expression TK_SEMICOLON
StatementNewScope ::= TK_BRACE_L Statement* TK_BRACE_R
Statement ::= StatementTypedef | StatementReturn | StatementLet | StatementBreak | StatementContinue | StatementExpression | FunctionPrototype

Identifier ::= LX_IDENTIFIER
GenericIdentifier ::= LX_IDENTIFIER TypeGenericArguments?

PostfixOperatorFunctionCall ::= FunctionCallArguments
PostfixOperatorMemberAccess ::= OperatorIdentifierMemberAccess (GenericIdentifier | Number)
PostfixOperatorStructInitializer ::= TK_BRACE_L PostfixOperatorStructInitializerFields? TK_BRACE_R
PostfixOperatorStructInitializerFields ::= PostfixOperatorStructInitializerField PostfixOperatorStructInitializerFieldNext*
PostfixOperatorStructInitializerFieldNext ::= TK_COMMA PostfixOperatorStructInitializerField
PostfixOperatorStructInitializerField ::= PostfixOperatorStructInitializerFieldIdentifier PostfixOperatorStructInitializerFieldValueDifferentToIdentifier?
PostfixOperatorStructInitializerFieldValueDifferentToIdentifier ::= TK_COLON NonAssignmentExpression
PostfixOperatorStructInitializerFieldIdentifier ::= (KW_SUP | KW_ELSE | Identifier)

OperatorIdentifierAssignment ::= (TK_DOUBLE_PIPE_EQUALS | TK_DOUBLE_AMPERSAND_EQUALS | TK_AMPERSAND_EQUALS | TK_PIPE_EQUALS | TK_CARET_EQUALS | TK_ADD_EQ | TK_SUB_EQ | TK_MUL_EQ | TK_DIV_EQ | TK_REM_EQ)
OperatorIdentifierEquality ::= (TK_EQ | TK_NE)
OperatorIdentifierRelation ::= (TK_LT | TK_GT | TK_LE | TK_GE | TK_SS)
OperatorIdentifierAdditive ::= (TK_ADD | TK_SUB)
OperatorIdentifierMultiplicative ::= (TK_MUL | TK_DIV | TK_REM)
OperatorIdentifierPipe ::= (TK_PIPE_ARROW_R | TK_PIPE_ARROW_L)
ParameterPassingConvention ::= TK_AMPERSAND KW_MUT?
OperatorIdentifierVariadic ::= TK_TRIPLE_DOT
OperatorIdentifierMemberAccess ::= (TK_DYNA_RES | TK_STAT_RES)
OperatorIdentifierPostfix ::= (PostfixOperatorFunctionCall | PostfixOperatorMemberAccess | TK_QST)

Literal ::= (LiteralNumber | LiteralString | LiteralChar | LiteralBoolean | LiteralTuple | LiteralRegex)
LiteralNumber ::= (LiteralNumberBase02 | LiteralNumberBase16 | LiteralNumberBase10)
LiteralString ::= LX_DOUBLE_QUOTE_STR
LiteralChar ::= LX_SINGLE_QUOTE_CHR
LiteralBoolean ::= (KW_TRUE | KW_FALSE)
LiteralRegex ::= LX_REGEX
LiteralTuple ::= TK_PAREN_L Expressions? TK_PAREN_R
LiteralNumberBase02 ::= LX_BIN_DIGITS
LiteralNumberBase10 ::= Number
LiteralNumberBase16 ::= LX_HEX_DIGITS

Number ::= NumericSign? NumericInteger NumericDecimal? NumericComplex? NumericExponent?
NumericSign ::= TK_ADD | TK_SUB
NumericInteger ::= LX_DEC_DIGITS
NumericDecimal ::= TK_DYNA_RES LX_DEC_DIGITS
NumericComplex ::= "i"
NumericExponent ::= "e" OperatorIdentifierAdditive? NumericInteger
