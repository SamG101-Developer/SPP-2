{
    parserClass = "org.intellij.sdk.language.parser.SppParser"
    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Spp"
    psiImplClassSuffix = "Impl"
    psiPackage="org.intellij.sdk.language.psi"
    psiImplPackage="org.intellij.sdk.language.psi.impl"

    elementTypeHolderClass = "org.intellij.sdk.language.psi.SppTypes"
    elementTypeClass = "org.intellij.sdk.language.psi.SppElementType"
    tokenTypeClass = "org.intellij.sdk.language.psi.SppTokenType"

    tokens = [
        space = "regexp:\s+"
        line_comment = "regexp:#.*"
        block_comment= "regexp:/\*([^(\*/)])*\*/"

        TK_DOUBLE_AMPERSAND = "&&"
        TK_DOUBLE_AMPERSAND_EQUALS = "&&="
        TK_DOUBLE_PIPE = "||"
        TK_DOUBLE_PIPE_EQUALS = "||="
        TK_AMPERSAND = "&"
        TK_AMPERSAND_EQUALS = "&="
        TK_PIPE = "|"
        TK_PIPE_EQUALS = "|="
        TK_CARET = "^"
        TK_CARET_EQUALS = "^="
        TK_EQ = "=="
        TK_NE = "!="
        TK_LE = "<="
        TK_GE = ">="
        TK_LT = "<"
        TK_GT = ">"
        TK_SS = "<=>"
        TK_ADD = "+"
        TK_SUB = "-"
        TK_MUL = "*"
        TK_DIV = "/"
        TK_REM = "%"
        TK_ADD_EQ = "+="
        TK_SUB_EQ = "-="
        TK_MUL_EQ = "*="
        TK_DIV_EQ = "/="
        TK_REM_EQ = "%="
        TK_PAREN_L = "("
        TK_PAREN_R = ")"
        TK_BRACK_L = "["
        TK_BRACK_R = "]"
        TK_BRACE_L = "{"
        TK_BRACE_R = "}"
        TK_QST = "?"
        TK_TRIPLE_DOT = "..."
        TK_COLON = ":"
        TK_DOT = "."
        TK_COMMA = ","
        TK_ASSIGN = "="
        TK_ARROW_R = "->"
        TK_AT = "@"
        TK_UNDERSCORE = "_"
        TK_NEW_LINE = ";"

        KW_MOD = "mod"
        KW_USE = "use"
        KW_ENUM = "enum"
        KW_FN = "fn"
        KW_GN = "gn"
        KW_MUT = "mut"
        KW_LET = "let"
        KW_IF = "if"
        KW_ELSE = "else"
        KW_WHILE = "while"
        KW_RET = "ret"
        KW_YIELD = "yield"
        KW_CLS = "cls"
        KW_WHERE = "where"
        KW_TRUE = "true"
        KW_FALSE = "false"
        KW_AS = "as"
        KW_SUP = "sup"
        KW_WITH = "with"
        KW_FOR = "for"
        KW_SELF = "self"
        KW_SELF_TYPE = "Self"
        LX_IDENTIFIER = "regexp:[a-z][_a-zA-Z0-9]*"
        LX_UPPER_IDENTIFIER = "regexp:[A-Z][_a-zA-Z0-9]*"
        LX_BIN_DIGITS = "regexp:0b[01]+"
        LX_HEX_DIGITS = "regexp:0x[0-9a-fA-F]+"
        LX_DEC_DIGITS = "regexp:[0-9]([0-9_]*[0-9])?"
        LX_DOUBLE_QUOTE_STR = "regexp:\"[^\"]*\""
        LX_REGEX = "regexp:r\".*\""
    ]
}


Program ::= ModulePrototype <<eof>>
ModulePrototype ::= Decorators? KW_MOD ModuleIdentifier TK_NEW_LINE ModuleImplementation
ModuleImplementation ::= ImportBlock? ModuleMember*
ModuleIdentifier ::= Identifier ModuleIdentifierNextPart*
ModuleIdentifierNextPart ::= TK_DOT Identifier
ModuleMember ::= (FunctionPrototype | EnumPrototype | ClassPrototype | SupPrototype)
ImportBlock ::= ImportStatement+
ImportStatement ::= KW_USE ImportIdentifier ImportWhat TK_NEW_LINE
ImportIdentifier ::= ImportIdentifierPart+
ImportIdentifierPart ::= Identifier TK_DOT
ImportWhat ::= (ImportAll | ImportSingle | ImportMultiple)
ImportAll ::= TK_MUL
ImportSingle ::= ImportType
ImportMultiple ::= TK_BRACE_L ImportTypes TK_BRACE_R
ImportTypes ::= ImportType ImportTypesNext*
ImportTypesNext ::= TK_COMMA ImportType
ImportType ::= UpperIdentifier ImportTypeAlias?
ImportTypeAlias ::= KW_AS UpperIdentifier
ClassPrototype ::= Decorators? KW_CLS ClassIdentifier TypeGenericParameters? WhereBlock? TK_BRACE_L ClassImplementation TK_BRACE_R
ClassImplementation ::= ClassMember*
ClassMember ::= ClassAttribute
ClassAttribute ::= Decorators? ClassAttributeIdentifier TK_COLON TypeIdentifier
ClassAttributeIdentifier ::= Identifier
ClassIdentifier ::= UpperIdentifier
SupPrototype ::= KW_SUP (SupPrototypeWithInherit | SupPrototypeNormal)
SupPrototypeNormal ::= TypeGenericParameters? SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupPrototypeWithInherit ::= TypeGenericParameters? SupIdentifier KW_FOR SupIdentifier WhereBlock? TK_BRACE_L SupImplementation TK_BRACE_R
SupImplementation ::= SupMember*
SupMember ::= (SupMethodPrototype | SupTypedef)
SupIdentifier ::= SingleTypeIdentifierNoSelf
SupTypedef ::= Decorators? StatementTypedef
SupMethodPrototype ::= FunctionPrototype
EnumPrototype ::= Decorators? KW_ENUM EnumIdentifier TypeGenericParameters? WhereBlock? TK_BRACE_L EnumImplementation TK_BRACE_R
EnumImplementation ::= EnumMember EnumMemberNext* TK_NEW_LINE
EnumMemberNext ::= TK_COMMA EnumMember
EnumMember ::= EnumMemberIdentifier EnumMemberValueWrapper?
EnumMemberValueWrapper ::= TK_ASSIGN NonAssignmentExpression
EnumMemberIdentifier ::= Identifier
EnumIdentifier ::= UpperIdentifier
FunctionStructureType ::= (KW_FN | KW_GN)
FunctionPrototype ::= Decorators? FunctionStructureType FunctionIdentifier TypeGenericParameters? FunctionParameters TK_ARROW_R TypeIdentifier WhereBlock? TK_BRACE_L FunctionImplementation TK_BRACE_R
FunctionImplementation ::= Statement*
FunctionIdentifier ::= Identifier
FunctionCallArguments ::= TK_PAREN_L FunctionCallArgumentsInternal? TK_PAREN_R
FunctionCallArgumentInternal ::= (FunctionCallNamedArgument | FunctionCallNormalArgument)
FunctionCallArgumentsInternalNext ::= TK_COMMA FunctionCallArgumentInternal
FunctionCallArgumentsInternal ::= FunctionCallArgumentInternal FunctionCallArgumentsInternalNext*
FunctionCallNormalArgument ::= ParameterPassingConvention? OperatorIdentifierVariadic? NonAssignmentExpression
FunctionCallNamedArgument ::= Identifier TK_ASSIGN ParameterPassingConvention? NonAssignmentExpression
FunctionParameters ::= TK_PAREN_L FunctionParametersInternal? TK_PAREN_R
FunctionParameterInternal ::= (FunctionParameterSelf | FunctionParameterVariadic | FunctionParameterOptional | FunctionParameterRequired)
FunctionParametersInternalNext ::= TK_COMMA FunctionParameterInternal
FunctionParametersInternal ::= FunctionParameterInternal FunctionParametersInternalNext*
FunctionParameterSelf ::= FunctionParameterSelfCallingConvention? KW_SELF
FunctionParameterSelfCallingConvention ::= (ParameterPassingConvention | KW_MUT)
FunctionParameterRequired ::= KW_MUT? Identifier TK_COLON ParameterPassingConvention? TypeIdentifier
FunctionParameterOptional ::= FunctionParameterRequired TK_ASSIGN NonAssignmentExpression
FunctionParameterVariadic ::= OperatorIdentifierVariadic FunctionParameterRequired
WhereBlock ::= KW_WHERE TK_BRACK_L WhereConstraints TK_BRACK_R
WhereConstraints ::= WhereConstraint WhereConstraintNext*
WhereConstraintNext ::= TK_COMMA WhereConstraint
WhereConstraint ::= TypeIdentifiers TK_COLON WhereConstraintChain
WhereConstraintChain ::= WhereConstraintChainElement WhereConstraintChainElementNext*
WhereConstraintChainElementNext ::= TK_AMPERSAND WhereConstraintChainElement
WhereConstraintChainElement ::= SingleTypeIdentifier
Decorator ::= TK_AT DecoratorIdentifier TypeGenericArguments? FunctionCallArguments?
Decorators ::= Decorator*
DecoratorIdentifier ::= ModuleIdentifier
Expressions ::= Expression ExpressionNext*
ExpressionNext ::= TK_COMMA Expression
Expression ::= AssignmentExpression
NonAssignmentExpression ::= Stage1BinaryExpression
AssignmentExpression ::= (AssignmentExpressionMultiple | AssignmentExpressionSingle)
AssignmentExpressionSingle ::= NonAssignmentExpression (OperatorIdentifierAssignment NonAssignmentExpression)?
AssignmentExpressionMultiple ::= NonAssignmentExpression AssignmentMultipleLhs* TK_ASSIGN NonAssignmentExpression
AssignmentMultipleLhs ::= TK_COMMA NonAssignmentExpression
Stage1BinaryExpression ::= Stage2BinaryExpression (Stage1BinaryOperatorIdentifier Stage1BinaryExpression)*
Stage2BinaryExpression ::= Stage3BinaryExpression (Stage2BinaryOperatorIdentifier Stage2BinaryExpression)*
Stage3BinaryExpression ::= Stage4BinaryExpression (Stage3BinaryOperatorIdentifier Stage3BinaryExpression)*
Stage4BinaryExpression ::= Stage5BinaryExpression (Stage4BinaryOperatorIdentifier Stage4BinaryExpression)*
Stage5BinaryExpression ::= PostfixExpression (Stage5BinaryOperatorIdentifier Stage5BinaryExpression)*
PostfixExpression ::= PrimaryExpression OperatorIdentifierPostfix*
PrimaryExpression ::= (StatementIf | StatementWhile | StatementNewScope | StatementYield | StatementWith | SelfKeyword | SingleTypeIdentifierForInitialization | SingleTypeIdentifier | Identifier | Literal | Lambda | OperatorIdentifierVariadic | ExpressionPlaceholder)
SelfKeyword ::= KW_SELF
SingleTypeIdentifierForInitialization ::= SingleTypeIdentifier PostfixOperatorStructInitializer
ExpressionPlaceholder ::= TK_UNDERSCORE
Lambda ::= LambdaCaptureList? LambdaParameters TK_ARROW_R StatementNewScope
LambdaCaptureList ::= TK_BRACK_L LambdaCaptureItem LambdaCaptureItemNext* TK_BRACK_R
LambdaCaptureItemNext ::= TK_COMMA LambdaCaptureItem
LambdaCaptureItem ::= LambdaCaptureItemAlias? ParameterPassingConvention? Identifier
LambdaCaptureItemAlias ::= Identifier TK_ASSIGN
LambdaParameters ::= TK_PAREN_L LambdaParametersRequired? TK_PAREN_R
LambdaParametersRequired ::= LambdaParameterRequired LambdaParameterRequiredNext*
LambdaParameterRequiredNext ::= TK_COMMA LambdaParameterRequired
LambdaParameterRequired ::= KW_MUT? Identifier
TypeIdentifier ::= (SingleTypeIdentifier | TupleTypeIdentifiers)
TypeIdentifiers ::= TypeIdentifier TypeIdentifierNext*
TypeIdentifierNext ::= TK_COMMA TypeIdentifier
SingleTypeIdentifier ::= (SingleTypeIdentifierWithSelf | SingleTypeIdentifierNoSelf)
TupleTypeIdentifiers ::= TK_PAREN_L TypeIdentifiers? TK_PAREN_R
SingleTypeIdentifierWithSelf ::= KW_SELF_TYPE TypeIdentifierUpperTypesFollowingSelf?
TypeIdentifierUpperTypesFollowingSelf ::= TK_DOT TypeIdentifierUpperTypes?
SingleTypeIdentifierNoSelf ::= TypeIdentifierNamespaceThenTypes
TypeIdentifierNamespace ::= TypeIdentifierNamespaceParts*
TypeIdentifierNamespaceParts ::= Identifier TK_DOT
TypeIdentifierNamespaceThenTypes ::= TypeIdentifierNamespace? TypeIdentifierUpperTypes
TypeIdentifierUpperTypes ::= TypeIdentifierUpperTypeExclusive TypeIdentifierNextUpperType*
TypeIdentifierNextUpperType ::= TK_DOT TypeIdentifierUpperTypeOrNumber
TypeIdentifierUpperTypeExclusive ::= GenericIdentifier
TypeIdentifierUpperTypeOrNumber ::= (GenericIdentifier | NumericInteger)
TypeGenericArguments ::= TK_BRACK_L TypeGenericArgumentsInternal? TK_BRACK_R
TypeGenericArgumentInternal ::= (TypeGenericArgumentNamed | TypeGenericArgumentNormal)
TypeGenericArgumentInternalNext ::= TK_COMMA TypeGenericArgumentInternal
TypeGenericArgumentsInternal ::= TypeGenericArgumentInternal TypeGenericArgumentInternalNext*
TypeGenericArgumentNormal ::= TypeIdentifier
TypeGenericArgumentNamed ::= UpperIdentifier TK_ASSIGN TypeIdentifier
TypeGenericParameters ::= TK_BRACK_L TypeGenericParametersInternal? TK_BRACK_R
TypeGenericParameterInternal ::= (TypeGenericParameterVariadic | TypeGenericParameterOptional | TypeGenericParameterRequired)
TypeGenericParameterInternalNext ::= TK_COMMA TypeGenericParameterInternal
TypeGenericParametersInternal ::= TypeGenericParameterInternal TypeGenericParameterInternalNext*
TypeGenericParameterRequired ::= UpperIdentifier TypeGenericParameterInlineConstraint?
TypeGenericParameterOptional ::= TypeGenericParameterRequired TK_ASSIGN TypeIdentifier
TypeGenericParameterVariadic ::= TK_TRIPLE_DOT TypeGenericParameterRequired
TypeGenericParameterInlineConstraint ::= TK_COLON WhereConstraintChain
StatementIf ::= KW_IF NonAssignmentExpression PatternOp? TK_BRACE_L StatementPattern* StatementPatternDefault? TK_BRACE_R
StatementPattern ::= PatternOp? PatternComposite PatternGuard? StatementNewScope
StatementPatternDefault ::= KW_ELSE StatementNewScope
PatternOp ::= Stage3BinaryOperatorIdentifier
PatternGuard ::= TK_DOUBLE_AMPERSAND NonAssignmentExpression
PatternComposite ::= PatternVal PatternValNext*
PatternVal ::= (PatternMatchObject | Literal)
PatternValNext ::= TK_PIPE PatternVal
PatternMatchObject ::= SingleTypeIdentifier PostfixOperatorStructInitializer
StatementWhile ::= KW_WHILE Expression StatementNewScope StatementsResidualAction?
StatementWith ::= KW_WITH Expression StatementAliasForWithExpression? StatementNewScope
StatementAliasForWithExpression ::= KW_AS LocalVariableIdentifier
StatementReturn ::= KW_RET Expression? TK_NEW_LINE
StatementYield ::= KW_YIELD ParameterPassingConvention? Expression?
StatementTypedef ::= KW_USE GenericIdentifier KW_AS TypeIdentifier TK_NEW_LINE
StatementLet ::= (StatementLetWithValue | StatementLetWithType)  TK_NEW_LINE
StatementLetWithValue ::= KW_LET LocalVariableIdentifiers TK_ASSIGN NonAssignmentExpression StatementsResidualAction?
StatementsResidualAction ::= KW_ELSE StatementNewScope
StatementLetWithType ::= KW_LET LocalVariableIdentifiers TK_COLON TypeIdentifier
LocalVariableIdentifier ::= KW_MUT? Identifier
LocalVariableIdentifiers ::= LocalVariableIdentifier LocalVariableIdentifierNext*
LocalVariableIdentifierNext ::= TK_COMMA LocalVariableIdentifier
StatementNewScope ::= TK_BRACE_L Statement* TK_BRACE_R
Statement ::= (Expression | StatementTypedef | StatementReturn | StatementLet | FunctionPrototype)
StatementExpression ::= Expression TK_NEW_LINE
Identifier ::= LX_IDENTIFIER
UpperIdentifier ::= LX_UPPER_IDENTIFIER
GenericIdentifier ::= LX_UPPER_IDENTIFIER TypeGenericArguments?
PostfixOperatorFunctionCall ::= TypeGenericArguments? FunctionCallArguments
PostfixOperatorMemberAccess ::= TK_DOT (Identifier | Number)
PostfixOperatorStructInitializer ::= TK_BRACE_L PostfixOperatorStructInitializerFields? TK_BRACE_R
PostfixOperatorStructInitializerFields ::= PostfixOperatorStructInitializerField PostfixOperatorStructInitializerFieldNext*
PostfixOperatorStructInitializerFieldNext ::= TK_COMMA PostfixOperatorStructInitializerField
PostfixOperatorStructInitializerField ::= PostfixOperatorStructInitializerFieldIdentifier PostfixOperatorStructInitializerFieldValueDifferentToIdentifier?
PostfixOperatorStructInitializerFieldValueDifferentToIdentifier ::= TK_ASSIGN NonAssignmentExpression
PostfixOperatorStructInitializerFieldIdentifier ::= (KW_SUP | KW_ELSE | Identifier)
OperatorIdentifierAssignment ::= (TK_DOUBLE_PIPE_EQUALS | TK_DOUBLE_AMPERSAND_EQUALS | TK_AMPERSAND_EQUALS | TK_PIPE_EQUALS | TK_CARET_EQUALS | TK_ADD_EQ | TK_SUB_EQ | TK_MUL_EQ | TK_DIV_EQ | TK_REM_EQ)
Stage1BinaryOperatorIdentifier ::= TK_DOUBLE_PIPE
Stage2BinaryOperatorIdentifier ::= TK_DOUBLE_AMPERSAND
Stage3BinaryOperatorIdentifier ::= (TK_EQ | TK_NE | TK_LT | TK_GT | TK_LE | TK_GE | TK_SS)
Stage4BinaryOperatorIdentifier ::= (TK_ADD | TK_SUB | TK_PIPE | TK_CARET)
Stage5BinaryOperatorIdentifier ::= (TK_MUL | TK_DIV | TK_REM | TK_AMPERSAND)
OperatorIdentifierAdditive ::= (TK_ADD | TK_SUB)
ParameterPassingConvention ::= TK_AMPERSAND KW_MUT?
OperatorIdentifierVariadic ::= TK_TRIPLE_DOT
OperatorIdentifierPostfix ::= (PostfixOperatorMemberAccess | PostfixOperatorFunctionCall | TK_QST)
Literal ::= (LiteralNumber | LiteralString | LiteralArray | LiteralBoolean | LiteralTuple | LiteralRegex)
LiteralNumber ::= (LiteralNumberBase02 | LiteralNumberBase16 | LiteralNumberBase10)
LiteralString ::= LX_DOUBLE_QUOTE_STR
LiteralArray ::= TK_BRACK_L Expressions? TK_BRACK_R
LiteralBoolean ::= (KW_TRUE | KW_FALSE)
LiteralRegex ::= LX_REGEX
LiteralTuple ::= TK_PAREN_L Expressions? TK_PAREN_R
LiteralNumberBase02 ::= LX_BIN_DIGITS
LiteralNumberBase10 ::= Number
LiteralNumberBase16 ::= LX_HEX_DIGITS
Number ::= NumericSign? NumericInteger NumericDecimal? NumericComplex? NumericExponent?
NumericSign ::= (TK_ADD | TK_SUB)
NumericInteger ::= LX_DEC_DIGITS
NumericDecimal ::= TK_DOT LX_DEC_DIGITS
NumericComplex ::= Character
NumericExponent ::= Character OperatorIdentifierAdditive? NumericInteger
